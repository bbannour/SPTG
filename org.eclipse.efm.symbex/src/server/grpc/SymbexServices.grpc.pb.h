// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: SymbexServices.proto
// Original file comments:
// ******************************************************************************
// Copyright (c) 2020 CEA LIST.
//
// All rights reserved. This program and the accompanying materials
// are made available under the terms of the Eclipse Public License v1.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v20.html
//
// Created on: 23 avr. 2020
//
// Contributors:
//  Arnault Lapitre (CEA LIST) arnault.lapitre@cea.fr
//  Erwan Mahe (CentraleSUpelec) erwan.mahe@student.ecp.fr
//   - Initial API and Implementation
// ****************************************************************************
//
#ifndef GRPC_SymbexServices_2eproto__INCLUDED
#define GRPC_SymbexServices_2eproto__INCLUDED

#include "SymbexServices.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace sep {
namespace grpc {

// The DIVERSITY/SYMBEX service definition.
class Symbex final {
 public:
  static constexpr char const* service_full_name() {
    return "sep.grpc.Symbex";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // //////////////////////////////////////////////////////////////////////////
    // Initialization
    virtual ::grpc::Status initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::sep::grpc::InitializationReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>> Asyncinitialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>>(AsyncinitializationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>> PrepareAsyncinitialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>>(PrepareAsyncinitializationRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Model Parsing
    virtual ::grpc::Status modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> AsyncmodelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(AsyncmodelParseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseRaw(context, request, cq));
    }
    virtual ::grpc::Status modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> AsyncmodelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(AsyncmodelParseFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseFileRaw(context, request, cq));
    }
    // Model Parsing for Raw Textual 
    virtual ::grpc::Status modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> AsyncmodelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(AsyncmodelParseTextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseTextRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // Model Evaluation
    virtual ::grpc::Status modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelEvalReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>> AsyncmodelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>>(AsyncmodelEvalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>> PrepareAsyncmodelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>>(PrepareAsyncmodelEvalRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // SYMBEX
    //
    // Symbex Evaluation Initialization
    virtual ::grpc::Status symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::sep::grpc::SymbexEvalInitReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>> AsyncsymbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>>(AsyncsymbexEvalInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>> PrepareAsyncsymbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>>(PrepareAsyncsymbexEvalInitRaw(context, request, cq));
    }
    // Symbex Step
    virtual ::grpc::Status symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::sep::grpc::SymbexEvalStepReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>> AsyncsymbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>>(AsyncsymbexEvalStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>> PrepareAsyncsymbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>>(PrepareAsyncsymbexEvalStepRaw(context, request, cq));
    }
    // Symbex Evaluation
    virtual ::grpc::Status symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::sep::grpc::SymbexEvalContextReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>> AsyncsymbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>>(AsyncsymbexEvalContextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>> PrepareAsyncsymbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>>(PrepareAsyncsymbexEvalContextRaw(context, request, cq));
    }
    // Symbex Evaluation of a Machine (by a string FQN_ID) on a symbolic Execution Context
    virtual ::grpc::Status symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalMachineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalMachineRaw(context, request, cq));
    }
    // Symbex Evaluation of a Machine (by a string FQN_ID) on a Symbex Context
    virtual ::grpc::Status symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableBasicReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>> AsyncsymbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>>(AsyncsymbexEvalBasicMachineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>> PrepareAsyncsymbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>>(PrepareAsyncsymbexEvalBasicMachineRaw(context, request, cq));
    }
    // Symbex Evaluation of a State (by a string FQN_ID) on a Symbex Context
    virtual ::grpc::Status symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalStateRaw(context, request, cq));
    }
    // Symbex Evaluation of a Transition (by a string FQN_ID) on a Context
    virtual ::grpc::Status symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalTransitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalTransitionRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // QUERY
    //
    // Symbex Query Variable Value, if the variable request set is empty, all variable values are returned 
    virtual ::grpc::Status queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryValueofVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryValueofVariableRaw(context, request, cq));
    }
    // Symbex Query Trace for Condition
    virtual ::grpc::Status queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryNodeConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryNodeConditionRaw(context, request, cq));
    }
    virtual ::grpc::Status queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryPathConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryPathConditionRaw(context, request, cq));
    }
    // Symbex Query Trace for IO élement (input / output / newfresh)
    virtual ::grpc::Status queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryTraceIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryTraceIORaw(context, request, cq));
    }
    // Symbex Query Trace for Executable element (machine / statemachine / state / transition)
    virtual ::grpc::Status queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryTraceExecutableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryTraceExecutableRaw(context, request, cq));
    }
    // EC tree Query Note : these might be merge with other query once matured
    virtual ::grpc::Status queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::GRPCExecutionContext* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>> AsyncqueryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>>(AsyncqueryECRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>> PrepareAsyncqueryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>>(PrepareAsyncqueryECRaw(context, request, cq));
    }
    virtual ::grpc::Status queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::ECReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>> AsyncqueryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>>(AsyncqueryChildContextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>> PrepareAsyncqueryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>>(PrepareAsyncqueryChildContextRaw(context, request, cq));
    }
    virtual ::grpc::Status queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::RuntimesStatusReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>> AsyncqueryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>>(AsyncqueryRuntimesStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>> PrepareAsyncqueryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>>(PrepareAsyncqueryRuntimesStatusRaw(context, request, cq));
    }
    // //////////////////////////////////////////////////////////////////////////
    // POST PROCESSING
    //
    virtual ::grpc::Status runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::sep::grpc::PostProcessingReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>> AsyncrunPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>>(AsyncrunPostProcessorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>> PrepareAsyncrunPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>>(PrepareAsyncrunPostProcessorRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // //////////////////////////////////////////////////////////////////////////
      // Initialization
      virtual void initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // //////////////////////////////////////////////////////////////////////////
      // Model Parsing
      virtual void modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Model Parsing for Raw Textual 
      virtual void modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // //////////////////////////////////////////////////////////////////////////
      // Model Evaluation
      virtual void modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // //////////////////////////////////////////////////////////////////////////
      // SYMBEX
      //
      // Symbex Evaluation Initialization
      virtual void symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Step
      virtual void symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Evaluation
      virtual void symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Evaluation of a Machine (by a string FQN_ID) on a symbolic Execution Context
      virtual void symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Evaluation of a Machine (by a string FQN_ID) on a Symbex Context
      virtual void symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Evaluation of a State (by a string FQN_ID) on a Symbex Context
      virtual void symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Evaluation of a Transition (by a string FQN_ID) on a Context
      virtual void symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // //////////////////////////////////////////////////////////////////////////
      // QUERY
      //
      // Symbex Query Variable Value, if the variable request set is empty, all variable values are returned 
      virtual void queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Query Trace for Condition
      virtual void queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Query Trace for IO élement (input / output / newfresh)
      virtual void queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Symbex Query Trace for Executable element (machine / statemachine / state / transition)
      virtual void queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // EC tree Query Note : these might be merge with other query once matured
      virtual void queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // //////////////////////////////////////////////////////////////////////////
      // POST PROCESSING
      //
      virtual void runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>* AsyncinitializationRaw(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::InitializationReply>* PrepareAsyncinitializationRaw(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* AsyncmodelParseRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* AsyncmodelParseFileRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseFileRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* AsyncmodelParseTextRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseTextRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>* AsyncmodelEvalRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ModelEvalReply>* PrepareAsyncmodelEvalRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>* AsyncsymbexEvalInitRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalInitReply>* PrepareAsyncsymbexEvalInitRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>* AsyncsymbexEvalStepRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalStepReply>* PrepareAsyncsymbexEvalStepRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>* AsyncsymbexEvalContextRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalContextReply>* PrepareAsyncsymbexEvalContextRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>* AsyncsymbexEvalBasicMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableBasicReply>* PrepareAsyncsymbexEvalBasicMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalStateRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalStateRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalTransitionRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalTransitionRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryValueofVariableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryValueofVariableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryNodeConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryNodeConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryPathConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryPathConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryTraceIORaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryTraceIORaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryTraceExecutableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryTraceExecutableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>* AsyncqueryECRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::GRPCExecutionContext>* PrepareAsyncqueryECRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>* AsyncqueryChildContextRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::ECReply>* PrepareAsyncqueryChildContextRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>* AsyncqueryRuntimesStatusRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::RuntimesStatusReply>* PrepareAsyncqueryRuntimesStatusRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>* AsyncrunPostProcessorRaw(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sep::grpc::PostProcessingReply>* PrepareAsyncrunPostProcessorRaw(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::sep::grpc::InitializationReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>> Asyncinitialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>>(AsyncinitializationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>> PrepareAsyncinitialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>>(PrepareAsyncinitializationRaw(context, request, cq));
    }
    ::grpc::Status modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> AsyncmodelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(AsyncmodelParseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseRaw(context, request, cq));
    }
    ::grpc::Status modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> AsyncmodelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(AsyncmodelParseFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseFileRaw(context, request, cq));
    }
    ::grpc::Status modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelParseReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> AsyncmodelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(AsyncmodelParseTextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>> PrepareAsyncmodelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>>(PrepareAsyncmodelParseTextRaw(context, request, cq));
    }
    ::grpc::Status modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::sep::grpc::ModelEvalReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>> AsyncmodelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>>(AsyncmodelEvalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>> PrepareAsyncmodelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>>(PrepareAsyncmodelEvalRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::sep::grpc::SymbexEvalInitReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>> AsyncsymbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>>(AsyncsymbexEvalInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>> PrepareAsyncsymbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>>(PrepareAsyncsymbexEvalInitRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::sep::grpc::SymbexEvalStepReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>> AsyncsymbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>>(AsyncsymbexEvalStepRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>> PrepareAsyncsymbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>>(PrepareAsyncsymbexEvalStepRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::sep::grpc::SymbexEvalContextReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>> AsyncsymbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>>(AsyncsymbexEvalContextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>> PrepareAsyncsymbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>>(PrepareAsyncsymbexEvalContextRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalMachineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalMachineRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableBasicReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>> AsyncsymbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>>(AsyncsymbexEvalBasicMachineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>> PrepareAsyncsymbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>>(PrepareAsyncsymbexEvalBasicMachineRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalStateRaw(context, request, cq));
    }
    ::grpc::Status symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::sep::grpc::SymbexEvalRunnableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> AsyncsymbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(AsyncsymbexEvalTransitionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>> PrepareAsyncsymbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>>(PrepareAsyncsymbexEvalTransitionRaw(context, request, cq));
    }
    ::grpc::Status queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryValueofVariableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryValueofVariableRaw(context, request, cq));
    }
    ::grpc::Status queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryNodeConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryNodeConditionRaw(context, request, cq));
    }
    ::grpc::Status queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryPathConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryPathConditionRaw(context, request, cq));
    }
    ::grpc::Status queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryTraceIORaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryTraceIORaw(context, request, cq));
    }
    ::grpc::Status queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::sep::grpc::QueryValueForVariableReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> AsyncqueryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(AsyncqueryTraceExecutableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>> PrepareAsyncqueryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>>(PrepareAsyncqueryTraceExecutableRaw(context, request, cq));
    }
    ::grpc::Status queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::GRPCExecutionContext* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>> AsyncqueryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>>(AsyncqueryECRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>> PrepareAsyncqueryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>>(PrepareAsyncqueryECRaw(context, request, cq));
    }
    ::grpc::Status queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::ECReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>> AsyncqueryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>>(AsyncqueryChildContextRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>> PrepareAsyncqueryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>>(PrepareAsyncqueryChildContextRaw(context, request, cq));
    }
    ::grpc::Status queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::sep::grpc::RuntimesStatusReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>> AsyncqueryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>>(AsyncqueryRuntimesStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>> PrepareAsyncqueryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>>(PrepareAsyncqueryRuntimesStatusRaw(context, request, cq));
    }
    ::grpc::Status runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::sep::grpc::PostProcessingReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>> AsyncrunPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>>(AsyncrunPostProcessorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>> PrepareAsyncrunPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>>(PrepareAsyncrunPostProcessorRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response, std::function<void(::grpc::Status)>) override;
      void initialization(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) override;
      void modelParse(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) override;
      void modelParseFile(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, std::function<void(::grpc::Status)>) override;
      void modelParseText(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response, std::function<void(::grpc::Status)>) override;
      void modelEval(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalInit(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalStep(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalContext(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalBasicMachine(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalState(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, std::function<void(::grpc::Status)>) override;
      void symbexEvalTransition(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) override;
      void queryValueofVariable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) override;
      void queryNodeCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) override;
      void queryPathCondition(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) override;
      void queryTraceIO(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, std::function<void(::grpc::Status)>) override;
      void queryTraceExecutable(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response, std::function<void(::grpc::Status)>) override;
      void queryEC(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response, std::function<void(::grpc::Status)>) override;
      void queryChildContext(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response, std::function<void(::grpc::Status)>) override;
      void queryRuntimesStatus(::grpc::ClientContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response, std::function<void(::grpc::Status)>) override;
      void runPostProcessor(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>* AsyncinitializationRaw(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::InitializationReply>* PrepareAsyncinitializationRaw(::grpc::ClientContext* context, const ::sep::grpc::InitializationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* AsyncmodelParseRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* AsyncmodelParseFileRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseFileRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* AsyncmodelParseTextRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelParseReply>* PrepareAsyncmodelParseTextRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>* AsyncmodelEvalRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ModelEvalReply>* PrepareAsyncmodelEvalRaw(::grpc::ClientContext* context, const ::sep::grpc::ModelDefinitionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>* AsyncsymbexEvalInitRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalInitReply>* PrepareAsyncsymbexEvalInitRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalInitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>* AsyncsymbexEvalStepRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalStepReply>* PrepareAsyncsymbexEvalStepRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalStepRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>* AsyncsymbexEvalContextRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalContextReply>* PrepareAsyncsymbexEvalContextRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalContextRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>* AsyncsymbexEvalBasicMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableBasicReply>* PrepareAsyncsymbexEvalBasicMachineRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalStateRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalStateRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* AsyncsymbexEvalTransitionRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::SymbexEvalRunnableReply>* PrepareAsyncsymbexEvalTransitionRaw(::grpc::ClientContext* context, const ::sep::grpc::SymbexEvalRunnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryValueofVariableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryValueofVariableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryNodeConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryNodeConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryPathConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryPathConditionRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryTraceIORaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryTraceIORaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* AsyncqueryTraceExecutableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::QueryValueForVariableReply>* PrepareAsyncqueryTraceExecutableRaw(::grpc::ClientContext* context, const ::sep::grpc::QueryValueForVariableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>* AsyncqueryECRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::GRPCExecutionContext>* PrepareAsyncqueryECRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>* AsyncqueryChildContextRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::ECReply>* PrepareAsyncqueryChildContextRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>* AsyncqueryRuntimesStatusRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::RuntimesStatusReply>* PrepareAsyncqueryRuntimesStatusRaw(::grpc::ClientContext* context, const ::sep::grpc::ECQuery& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>* AsyncrunPostProcessorRaw(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sep::grpc::PostProcessingReply>* PrepareAsyncrunPostProcessorRaw(::grpc::ClientContext* context, const ::sep::grpc::PostProcessingRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_initialization_;
    const ::grpc::internal::RpcMethod rpcmethod_modelParse_;
    const ::grpc::internal::RpcMethod rpcmethod_modelParseFile_;
    const ::grpc::internal::RpcMethod rpcmethod_modelParseText_;
    const ::grpc::internal::RpcMethod rpcmethod_modelEval_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalInit_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalStep_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalContext_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalMachine_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalBasicMachine_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalState_;
    const ::grpc::internal::RpcMethod rpcmethod_symbexEvalTransition_;
    const ::grpc::internal::RpcMethod rpcmethod_queryValueofVariable_;
    const ::grpc::internal::RpcMethod rpcmethod_queryNodeCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_queryPathCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_queryTraceIO_;
    const ::grpc::internal::RpcMethod rpcmethod_queryTraceExecutable_;
    const ::grpc::internal::RpcMethod rpcmethod_queryEC_;
    const ::grpc::internal::RpcMethod rpcmethod_queryChildContext_;
    const ::grpc::internal::RpcMethod rpcmethod_queryRuntimesStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_runPostProcessor_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // //////////////////////////////////////////////////////////////////////////
    // Initialization
    virtual ::grpc::Status initialization(::grpc::ServerContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response);
    // //////////////////////////////////////////////////////////////////////////
    // Model Parsing
    virtual ::grpc::Status modelParse(::grpc::ServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response);
    virtual ::grpc::Status modelParseFile(::grpc::ServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response);
    // Model Parsing for Raw Textual 
    virtual ::grpc::Status modelParseText(::grpc::ServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response);
    // //////////////////////////////////////////////////////////////////////////
    // Model Evaluation
    virtual ::grpc::Status modelEval(::grpc::ServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response);
    // //////////////////////////////////////////////////////////////////////////
    // SYMBEX
    //
    // Symbex Evaluation Initialization
    virtual ::grpc::Status symbexEvalInit(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response);
    // Symbex Step
    virtual ::grpc::Status symbexEvalStep(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response);
    // Symbex Evaluation
    virtual ::grpc::Status symbexEvalContext(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response);
    // Symbex Evaluation of a Machine (by a string FQN_ID) on a symbolic Execution Context
    virtual ::grpc::Status symbexEvalMachine(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response);
    // Symbex Evaluation of a Machine (by a string FQN_ID) on a Symbex Context
    virtual ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response);
    // Symbex Evaluation of a State (by a string FQN_ID) on a Symbex Context
    virtual ::grpc::Status symbexEvalState(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response);
    // Symbex Evaluation of a Transition (by a string FQN_ID) on a Context
    virtual ::grpc::Status symbexEvalTransition(::grpc::ServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response);
    // //////////////////////////////////////////////////////////////////////////
    // QUERY
    //
    // Symbex Query Variable Value, if the variable request set is empty, all variable values are returned 
    virtual ::grpc::Status queryValueofVariable(::grpc::ServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response);
    // Symbex Query Trace for Condition
    virtual ::grpc::Status queryNodeCondition(::grpc::ServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response);
    virtual ::grpc::Status queryPathCondition(::grpc::ServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response);
    // Symbex Query Trace for IO élement (input / output / newfresh)
    virtual ::grpc::Status queryTraceIO(::grpc::ServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response);
    // Symbex Query Trace for Executable element (machine / statemachine / state / transition)
    virtual ::grpc::Status queryTraceExecutable(::grpc::ServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response);
    // EC tree Query Note : these might be merge with other query once matured
    virtual ::grpc::Status queryEC(::grpc::ServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response);
    virtual ::grpc::Status queryChildContext(::grpc::ServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response);
    virtual ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response);
    // //////////////////////////////////////////////////////////////////////////
    // POST PROCESSING
    //
    virtual ::grpc::Status runPostProcessor(::grpc::ServerContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_initialization() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinitialization(::grpc::ServerContext* context, ::sep::grpc::InitializationRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::InitializationReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modelParse() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParse(::grpc::ServerContext* context, ::sep::grpc::ModelDefinitionRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::ModelParseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modelParseFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParseFile(::grpc::ServerContext* context, ::sep::grpc::ModelDefinitionRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::ModelParseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modelParseText() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParseText(::grpc::ServerContext* context, ::sep::grpc::ModelDefinitionRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::ModelParseReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_modelEval() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelEval(::grpc::ServerContext* context, ::sep::grpc::ModelDefinitionRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::ModelEvalReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalInit(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalInitRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalInitReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalStep(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalStepRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalStepReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalContext(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalContextRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalContextReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalMachine(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalRunnableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalRunnableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalBasicMachine(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalRunnableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalRunnableBasicReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalState(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalRunnableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalRunnableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalTransition(::grpc::ServerContext* context, ::sep::grpc::SymbexEvalRunnableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::SymbexEvalRunnableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryValueofVariable(::grpc::ServerContext* context, ::sep::grpc::QueryValueForVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::QueryValueForVariableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryNodeCondition(::grpc::ServerContext* context, ::sep::grpc::QueryValueForVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::QueryValueForVariableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryPathCondition(::grpc::ServerContext* context, ::sep::grpc::QueryValueForVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::QueryValueForVariableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryTraceIO(::grpc::ServerContext* context, ::sep::grpc::QueryValueForVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::QueryValueForVariableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryTraceExecutable(::grpc::ServerContext* context, ::sep::grpc::QueryValueForVariableRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::QueryValueForVariableReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryEC() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryEC(::grpc::ServerContext* context, ::sep::grpc::ECQuery* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::GRPCExecutionContext>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryChildContext() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryChildContext(::grpc::ServerContext* context, ::sep::grpc::ECQuery* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::ECReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryRuntimesStatus(::grpc::ServerContext* context, ::sep::grpc::ECQuery* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::RuntimesStatusReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrunPostProcessor(::grpc::ServerContext* context, ::sep::grpc::PostProcessingRequest* request, ::grpc::ServerAsyncResponseWriter< ::sep::grpc::PostProcessingReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_initialization<WithAsyncMethod_modelParse<WithAsyncMethod_modelParseFile<WithAsyncMethod_modelParseText<WithAsyncMethod_modelEval<WithAsyncMethod_symbexEvalInit<WithAsyncMethod_symbexEvalStep<WithAsyncMethod_symbexEvalContext<WithAsyncMethod_symbexEvalMachine<WithAsyncMethod_symbexEvalBasicMachine<WithAsyncMethod_symbexEvalState<WithAsyncMethod_symbexEvalTransition<WithAsyncMethod_queryValueofVariable<WithAsyncMethod_queryNodeCondition<WithAsyncMethod_queryPathCondition<WithAsyncMethod_queryTraceIO<WithAsyncMethod_queryTraceExecutable<WithAsyncMethod_queryEC<WithAsyncMethod_queryChildContext<WithAsyncMethod_queryRuntimesStatus<WithAsyncMethod_runPostProcessor<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_initialization() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::InitializationRequest, ::sep::grpc::InitializationReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::InitializationRequest* request, ::sep::grpc::InitializationReply* response) { return this->initialization(context, request, response); }));}
    void SetMessageAllocatorFor_initialization(
        ::grpc::MessageAllocator< ::sep::grpc::InitializationRequest, ::sep::grpc::InitializationReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::InitializationRequest, ::sep::grpc::InitializationReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initialization(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modelParse() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response) { return this->modelParse(context, request, response); }));}
    void SetMessageAllocatorFor_modelParse(
        ::grpc::MessageAllocator< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParse(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modelParseFile() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response) { return this->modelParseFile(context, request, response); }));}
    void SetMessageAllocatorFor_modelParseFile(
        ::grpc::MessageAllocator< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParseFile(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modelParseText() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelParseReply* response) { return this->modelParseText(context, request, response); }));}
    void SetMessageAllocatorFor_modelParseText(
        ::grpc::MessageAllocator< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParseText(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_modelEval() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelEvalReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ModelDefinitionRequest* request, ::sep::grpc::ModelEvalReply* response) { return this->modelEval(context, request, response); }));}
    void SetMessageAllocatorFor_modelEval(
        ::grpc::MessageAllocator< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelEvalReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelEvalReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelEval(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalInitRequest, ::sep::grpc::SymbexEvalInitReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalInitRequest* request, ::sep::grpc::SymbexEvalInitReply* response) { return this->symbexEvalInit(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalInit(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalInitRequest, ::sep::grpc::SymbexEvalInitReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalInitRequest, ::sep::grpc::SymbexEvalInitReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalInit(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalStepRequest, ::sep::grpc::SymbexEvalStepReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalStepRequest* request, ::sep::grpc::SymbexEvalStepReply* response) { return this->symbexEvalStep(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalStep(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalStepRequest, ::sep::grpc::SymbexEvalStepReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalStepRequest, ::sep::grpc::SymbexEvalStepReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalStep(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalContextRequest, ::sep::grpc::SymbexEvalContextReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalContextRequest* request, ::sep::grpc::SymbexEvalContextReply* response) { return this->symbexEvalContext(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalContext(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalContextRequest, ::sep::grpc::SymbexEvalContextReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalContextRequest, ::sep::grpc::SymbexEvalContextReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalContext(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response) { return this->symbexEvalMachine(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalMachine(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalMachine(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableBasicReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableBasicReply* response) { return this->symbexEvalBasicMachine(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalBasicMachine(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableBasicReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableBasicReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalBasicMachine(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response) { return this->symbexEvalState(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalState(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalState(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::SymbexEvalRunnableRequest* request, ::sep::grpc::SymbexEvalRunnableReply* response) { return this->symbexEvalTransition(context, request, response); }));}
    void SetMessageAllocatorFor_symbexEvalTransition(
        ::grpc::MessageAllocator< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalTransition(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response) { return this->queryValueofVariable(context, request, response); }));}
    void SetMessageAllocatorFor_queryValueofVariable(
        ::grpc::MessageAllocator< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryValueofVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response) { return this->queryNodeCondition(context, request, response); }));}
    void SetMessageAllocatorFor_queryNodeCondition(
        ::grpc::MessageAllocator< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryNodeCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response) { return this->queryPathCondition(context, request, response); }));}
    void SetMessageAllocatorFor_queryPathCondition(
        ::grpc::MessageAllocator< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryPathCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response) { return this->queryTraceIO(context, request, response); }));}
    void SetMessageAllocatorFor_queryTraceIO(
        ::grpc::MessageAllocator< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryTraceIO(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::QueryValueForVariableRequest* request, ::sep::grpc::QueryValueForVariableReply* response) { return this->queryTraceExecutable(context, request, response); }));}
    void SetMessageAllocatorFor_queryTraceExecutable(
        ::grpc::MessageAllocator< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryTraceExecutable(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryEC() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::GRPCExecutionContext>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::GRPCExecutionContext* response) { return this->queryEC(context, request, response); }));}
    void SetMessageAllocatorFor_queryEC(
        ::grpc::MessageAllocator< ::sep::grpc::ECQuery, ::sep::grpc::GRPCExecutionContext>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::GRPCExecutionContext>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryEC(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryChildContext() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::ECReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::ECReply* response) { return this->queryChildContext(context, request, response); }));}
    void SetMessageAllocatorFor_queryChildContext(
        ::grpc::MessageAllocator< ::sep::grpc::ECQuery, ::sep::grpc::ECReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::ECReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryChildContext(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::RuntimesStatusReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::ECQuery* request, ::sep::grpc::RuntimesStatusReply* response) { return this->queryRuntimesStatus(context, request, response); }));}
    void SetMessageAllocatorFor_queryRuntimesStatus(
        ::grpc::MessageAllocator< ::sep::grpc::ECQuery, ::sep::grpc::RuntimesStatusReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::ECQuery, ::sep::grpc::RuntimesStatusReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryRuntimesStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::sep::grpc::PostProcessingRequest, ::sep::grpc::PostProcessingReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sep::grpc::PostProcessingRequest* request, ::sep::grpc::PostProcessingReply* response) { return this->runPostProcessor(context, request, response); }));}
    void SetMessageAllocatorFor_runPostProcessor(
        ::grpc::MessageAllocator< ::sep::grpc::PostProcessingRequest, ::sep::grpc::PostProcessingReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sep::grpc::PostProcessingRequest, ::sep::grpc::PostProcessingReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* runPostProcessor(
      ::grpc::CallbackServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_initialization<WithCallbackMethod_modelParse<WithCallbackMethod_modelParseFile<WithCallbackMethod_modelParseText<WithCallbackMethod_modelEval<WithCallbackMethod_symbexEvalInit<WithCallbackMethod_symbexEvalStep<WithCallbackMethod_symbexEvalContext<WithCallbackMethod_symbexEvalMachine<WithCallbackMethod_symbexEvalBasicMachine<WithCallbackMethod_symbexEvalState<WithCallbackMethod_symbexEvalTransition<WithCallbackMethod_queryValueofVariable<WithCallbackMethod_queryNodeCondition<WithCallbackMethod_queryPathCondition<WithCallbackMethod_queryTraceIO<WithCallbackMethod_queryTraceExecutable<WithCallbackMethod_queryEC<WithCallbackMethod_queryChildContext<WithCallbackMethod_queryRuntimesStatus<WithCallbackMethod_runPostProcessor<Service > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_initialization() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modelParse() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modelParseFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modelParseText() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_modelEval() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryEC() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryChildContext() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_initialization() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinitialization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modelParse() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParse(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modelParseFile() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParseFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modelParseText() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelParseText(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_modelEval() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmodelEval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalStep(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalContext(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalMachine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalBasicMachine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsymbexEvalTransition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryValueofVariable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryNodeCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryPathCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryTraceIO(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryTraceExecutable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryEC() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryEC(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryChildContext() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryChildContext(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestqueryRuntimesStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestrunPostProcessor(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_initialization() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->initialization(context, request, response); }));
    }
    ~WithRawCallbackMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* initialization(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modelParse() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modelParse(context, request, response); }));
    }
    ~WithRawCallbackMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParse(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modelParseFile() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modelParseFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParseFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modelParseText() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modelParseText(context, request, response); }));
    }
    ~WithRawCallbackMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelParseText(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_modelEval() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->modelEval(context, request, response); }));
    }
    ~WithRawCallbackMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* modelEval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalInit(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalStep(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalStep(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalContext(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalContext(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalMachine(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalMachine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalBasicMachine(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalBasicMachine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalState(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->symbexEvalTransition(context, request, response); }));
    }
    ~WithRawCallbackMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* symbexEvalTransition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryValueofVariable(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryValueofVariable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryNodeCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryNodeCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryPathCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryPathCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryTraceIO(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryTraceIO(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryTraceExecutable(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryTraceExecutable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryEC() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryEC(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryEC(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryChildContext() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryChildContext(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryChildContext(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->queryRuntimesStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* queryRuntimesStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->runPostProcessor(context, request, response); }));
    }
    ~WithRawCallbackMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* runPostProcessor(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_initialization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_initialization() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::InitializationRequest, ::sep::grpc::InitializationReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::InitializationRequest, ::sep::grpc::InitializationReply>* streamer) {
                       return this->Streamedinitialization(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_initialization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status initialization(::grpc::ServerContext* /*context*/, const ::sep::grpc::InitializationRequest* /*request*/, ::sep::grpc::InitializationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinitialization(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::InitializationRequest,::sep::grpc::InitializationReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modelParse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modelParse() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* streamer) {
                       return this->StreamedmodelParse(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modelParse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modelParse(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodelParse(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ModelDefinitionRequest,::sep::grpc::ModelParseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modelParseFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modelParseFile() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* streamer) {
                       return this->StreamedmodelParseFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modelParseFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modelParseFile(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodelParseFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ModelDefinitionRequest,::sep::grpc::ModelParseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modelParseText : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modelParseText() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelParseReply>* streamer) {
                       return this->StreamedmodelParseText(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modelParseText() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modelParseText(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelParseReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodelParseText(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ModelDefinitionRequest,::sep::grpc::ModelParseReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_modelEval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_modelEval() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelEvalReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ModelDefinitionRequest, ::sep::grpc::ModelEvalReply>* streamer) {
                       return this->StreamedmodelEval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_modelEval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status modelEval(::grpc::ServerContext* /*context*/, const ::sep::grpc::ModelDefinitionRequest* /*request*/, ::sep::grpc::ModelEvalReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmodelEval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ModelDefinitionRequest,::sep::grpc::ModelEvalReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalInit() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalInitRequest, ::sep::grpc::SymbexEvalInitReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalInitRequest, ::sep::grpc::SymbexEvalInitReply>* streamer) {
                       return this->StreamedsymbexEvalInit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalInit(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalInitRequest* /*request*/, ::sep::grpc::SymbexEvalInitReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalInitRequest,::sep::grpc::SymbexEvalInitReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalStep : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalStep() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalStepRequest, ::sep::grpc::SymbexEvalStepReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalStepRequest, ::sep::grpc::SymbexEvalStepReply>* streamer) {
                       return this->StreamedsymbexEvalStep(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalStep() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalStep(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalStepRequest* /*request*/, ::sep::grpc::SymbexEvalStepReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalStep(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalStepRequest,::sep::grpc::SymbexEvalStepReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalContext() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalContextRequest, ::sep::grpc::SymbexEvalContextReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalContextRequest, ::sep::grpc::SymbexEvalContextReply>* streamer) {
                       return this->StreamedsymbexEvalContext(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalContextRequest* /*request*/, ::sep::grpc::SymbexEvalContextReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalContext(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalContextRequest,::sep::grpc::SymbexEvalContextReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalMachine() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* streamer) {
                       return this->StreamedsymbexEvalMachine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalMachine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalRunnableRequest,::sep::grpc::SymbexEvalRunnableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalBasicMachine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalBasicMachine() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableBasicReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableBasicReply>* streamer) {
                       return this->StreamedsymbexEvalBasicMachine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalBasicMachine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalBasicMachine(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableBasicReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalBasicMachine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalRunnableRequest,::sep::grpc::SymbexEvalRunnableBasicReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalState() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* streamer) {
                       return this->StreamedsymbexEvalState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalState(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalRunnableRequest,::sep::grpc::SymbexEvalRunnableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_symbexEvalTransition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_symbexEvalTransition() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::SymbexEvalRunnableRequest, ::sep::grpc::SymbexEvalRunnableReply>* streamer) {
                       return this->StreamedsymbexEvalTransition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_symbexEvalTransition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status symbexEvalTransition(::grpc::ServerContext* /*context*/, const ::sep::grpc::SymbexEvalRunnableRequest* /*request*/, ::sep::grpc::SymbexEvalRunnableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsymbexEvalTransition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::SymbexEvalRunnableRequest,::sep::grpc::SymbexEvalRunnableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryValueofVariable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryValueofVariable() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* streamer) {
                       return this->StreamedqueryValueofVariable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryValueofVariable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryValueofVariable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryValueofVariable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::QueryValueForVariableRequest,::sep::grpc::QueryValueForVariableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryNodeCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryNodeCondition() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* streamer) {
                       return this->StreamedqueryNodeCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryNodeCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryNodeCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryNodeCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::QueryValueForVariableRequest,::sep::grpc::QueryValueForVariableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryPathCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryPathCondition() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* streamer) {
                       return this->StreamedqueryPathCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryPathCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryPathCondition(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryPathCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::QueryValueForVariableRequest,::sep::grpc::QueryValueForVariableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryTraceIO : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryTraceIO() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* streamer) {
                       return this->StreamedqueryTraceIO(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryTraceIO() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryTraceIO(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryTraceIO(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::QueryValueForVariableRequest,::sep::grpc::QueryValueForVariableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryTraceExecutable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryTraceExecutable() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::QueryValueForVariableRequest, ::sep::grpc::QueryValueForVariableReply>* streamer) {
                       return this->StreamedqueryTraceExecutable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryTraceExecutable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryTraceExecutable(::grpc::ServerContext* /*context*/, const ::sep::grpc::QueryValueForVariableRequest* /*request*/, ::sep::grpc::QueryValueForVariableReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryTraceExecutable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::QueryValueForVariableRequest,::sep::grpc::QueryValueForVariableReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryEC : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryEC() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ECQuery, ::sep::grpc::GRPCExecutionContext>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ECQuery, ::sep::grpc::GRPCExecutionContext>* streamer) {
                       return this->StreamedqueryEC(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryEC() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryEC(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::GRPCExecutionContext* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryEC(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ECQuery,::sep::grpc::GRPCExecutionContext>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryChildContext : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryChildContext() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ECQuery, ::sep::grpc::ECReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ECQuery, ::sep::grpc::ECReply>* streamer) {
                       return this->StreamedqueryChildContext(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryChildContext() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryChildContext(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::ECReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryChildContext(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ECQuery,::sep::grpc::ECReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_queryRuntimesStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_queryRuntimesStatus() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::ECQuery, ::sep::grpc::RuntimesStatusReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::ECQuery, ::sep::grpc::RuntimesStatusReply>* streamer) {
                       return this->StreamedqueryRuntimesStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_queryRuntimesStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status queryRuntimesStatus(::grpc::ServerContext* /*context*/, const ::sep::grpc::ECQuery* /*request*/, ::sep::grpc::RuntimesStatusReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedqueryRuntimesStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::ECQuery,::sep::grpc::RuntimesStatusReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_runPostProcessor : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_runPostProcessor() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sep::grpc::PostProcessingRequest, ::sep::grpc::PostProcessingReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sep::grpc::PostProcessingRequest, ::sep::grpc::PostProcessingReply>* streamer) {
                       return this->StreamedrunPostProcessor(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_runPostProcessor() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status runPostProcessor(::grpc::ServerContext* /*context*/, const ::sep::grpc::PostProcessingRequest* /*request*/, ::sep::grpc::PostProcessingReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedrunPostProcessor(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sep::grpc::PostProcessingRequest,::sep::grpc::PostProcessingReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_initialization<WithStreamedUnaryMethod_modelParse<WithStreamedUnaryMethod_modelParseFile<WithStreamedUnaryMethod_modelParseText<WithStreamedUnaryMethod_modelEval<WithStreamedUnaryMethod_symbexEvalInit<WithStreamedUnaryMethod_symbexEvalStep<WithStreamedUnaryMethod_symbexEvalContext<WithStreamedUnaryMethod_symbexEvalMachine<WithStreamedUnaryMethod_symbexEvalBasicMachine<WithStreamedUnaryMethod_symbexEvalState<WithStreamedUnaryMethod_symbexEvalTransition<WithStreamedUnaryMethod_queryValueofVariable<WithStreamedUnaryMethod_queryNodeCondition<WithStreamedUnaryMethod_queryPathCondition<WithStreamedUnaryMethod_queryTraceIO<WithStreamedUnaryMethod_queryTraceExecutable<WithStreamedUnaryMethod_queryEC<WithStreamedUnaryMethod_queryChildContext<WithStreamedUnaryMethod_queryRuntimesStatus<WithStreamedUnaryMethod_runPostProcessor<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_initialization<WithStreamedUnaryMethod_modelParse<WithStreamedUnaryMethod_modelParseFile<WithStreamedUnaryMethod_modelParseText<WithStreamedUnaryMethod_modelEval<WithStreamedUnaryMethod_symbexEvalInit<WithStreamedUnaryMethod_symbexEvalStep<WithStreamedUnaryMethod_symbexEvalContext<WithStreamedUnaryMethod_symbexEvalMachine<WithStreamedUnaryMethod_symbexEvalBasicMachine<WithStreamedUnaryMethod_symbexEvalState<WithStreamedUnaryMethod_symbexEvalTransition<WithStreamedUnaryMethod_queryValueofVariable<WithStreamedUnaryMethod_queryNodeCondition<WithStreamedUnaryMethod_queryPathCondition<WithStreamedUnaryMethod_queryTraceIO<WithStreamedUnaryMethod_queryTraceExecutable<WithStreamedUnaryMethod_queryEC<WithStreamedUnaryMethod_queryChildContext<WithStreamedUnaryMethod_queryRuntimesStatus<WithStreamedUnaryMethod_runPostProcessor<Service > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpc
}  // namespace sep


#endif  // GRPC_SymbexServices_2eproto__INCLUDED
