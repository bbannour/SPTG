/*******************************************************************************
 * Copyright (c) 2016 CEA LIST.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Created on: 3 juin 2010
 *
 * Contributors:
 *  Arnault Lapitre (CEA LIST) arnault.lapitre@cea.fr
 *   - Initial API and implementation
 ******************************************************************************/

#include "AvmMathPrimitive.h"

#include <computer/EvaluationEnvironment.h>
#include <computer/ExecutionEnvironment.h>

#include <fml/expression/AvmCode.h>
#include <fml/expression/ExpressionEval.h>


namespace sep
{

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH MIN
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_MIN::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::min( ENV.mARG->at(0).bfCode() );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH MAX
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_MAX::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::max( ENV.mARG->at(0).bfCode() );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH RANDOM
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_RANDOM::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::random( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ABS
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ABS::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::abs( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH CEIL
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_CEIL::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::ceil( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH FLOOR
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_FLOOR::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::floor( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ROUND
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ROUND::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::round( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH TRUNCATE
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_TRUNCATE::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::truncate( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH MOD
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_MOD::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::mod(ENV.mARG->at(0), ENV.mARG->at(1));

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH SQRT
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_SQRT::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::sqrt( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH EXP
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_EXP::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::exp( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH LOG
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_LOG::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::log( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH SIN
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_SIN::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::sin( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH COS
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_COS::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::cos( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH TAN
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_TAN::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::tan( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH SINH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_SINH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::sinh( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH COSH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_COSH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::cosh( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH TANH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_TANH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::tanh( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ASIN
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ASIN::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::asin( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ACOS
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ACOS::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::acos( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ATAN
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ATAN::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::atan( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ATAN2
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ATAN2::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::atan2(ENV.mARG->at(1), ENV.mARG->at(1));

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ASINH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ASINH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::asinh( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ACOSH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ACOSH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::acosh( ENV.mARG->at(0) );

	return( true );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///// MATH ATANH
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AvmPrimitive_ATANH::seval(EvaluationEnvironment & ENV)
{
	ENV.outVAL = ExpressionEval::atanh( ENV.mARG->at(0) );

	return( true );
}



}
